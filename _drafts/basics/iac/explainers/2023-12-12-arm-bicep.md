---
title: Azure-Specific Infrastructure as Code Tools
categories: basics iac explainer
sort_order: 2
description: Azure has a set of tools you can use to manage Azure
---
Microsoft has a native set of tools for IaC that can only be used for managing Azure resources, namely **ARM templates** and **Bicep**. This blog will use Terraform instead of these tools, but don't let that deter *you* from using them instead of Terraform.<!--more--> Honestly, I like ARM templates and Bicep more, but Terraform will allow us some specific things that we can't do with ARM templates and Bicep. Azure's tools are completely free whereas Terraform may cost you some :money_with_wings: depending on how you implement it.

## ARM Templates

[ARM templates](https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/overview) allow you to declaratively define and deploy your Azure resources. They are simply JSON files that look something like this:

``` json
"resources": [
  {
    "type": "Microsoft.Storage/storageAccounts",
    "apiVersion": "2022-09-01",
    "name": "mystorageaccount",
    "location": "centralus",
    "sku": {
      "name": "Standard_LRS"
    },
    "kind": "StorageV2"
  },
]
```

The example above is an ARM template that would create an [Azure storage account](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview) in the Central US region. There are different ways to deploy ARM templates, but the most basic way is to use the command line. Let's say we saved the above file as `storage.json`. If you used the {% include reference.html item='azure_cli' %}, it would be something like this (assuming you already created the `{{ site.fake_company_code }}-storage` resource group):

``` bash
az deployment group create --resource-group {{ site.fake_company_code }}-storage --template-file storage.json
```

It is a very simple example, but you will often need to get more complex. If you wanted to deploy two different storage accounts in the Central US region with different names, you could make a parameter for the name and specify the name when you deploy them. In our `storage.json` ARM template, we're going to create a parameter named `storageAccountName` and reference it in the resource definition.

``` json
"parameters": {
  "storageAccountName": {
    "type": "string"
  }
},
"resources": [
  {
    "type": "Microsoft.Storage/storageAccounts",
    "apiVersion": "2022-09-01",
    "name": "[parameters('storageAccountName')]",
    "location": "centralus",
    "sku": {
      "name": "Standard_LRS"
    },
    "kind": "StorageV2"
  },
]
```

To deploy two storage accounts this, you will need to run this twice, specifying the storage account name as a parameter each time.

``` bash
az deployment group create --resource-group {{ site.fake_company_code }}-storage --template-file storage.json \
    --parameters storageAccountName='mystorageaccount'
az deployment group create --resource-group {{ site.fake_company_code }}-storage --template-file storage.json \
    --parameters storageAccountName='ohlookanotherstorageaccount'
```

If this all seems fun and exciting, welcome to the world of IaC! If you're unimpressed, then let me assure you that this is a very rudimentary example and you can do way more stuff, such as:

- Deploy multiple resources
- Create parameter files to store different deployment configurations
- Deploy different types of resources in the correct order (some of which may depend on each other)
- Use variables and functions for more complex deployments, such as creating loops to deploy multiple NICs on a VM
- Create ARM templates that can be called from other ARM templates

## Bicep

Once you start writing ARM template files, you may notice that there's a lot of JSON you have to wade through to get to the parts you're interested in. We love JSON because it's easier to read than its earlier cousins like XML. But there's still a lot of brackets and squiggles that need to be opened and closed. Plus, once you start writing ARM templates for real, you'll notice that your more complex functions may be hard to read. For example, look at this variable:

``` json
"variables" {
    "privateIPAddress": "[if(empty(parameters('ipAddress')), json('null'), parameters('ipAddress'))]"
}
```

[Bicep](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep) is a different IaC language developed by Microsoft for deploying Azure resources. It basically shortens the JSON and makes it easier to read. For example, the above variable could be written like this in Bicep:

``` terraform
var privateIPAddress = empty(ipAddress) ? null : ipAddress
```

It's more compact and easier to read, especially after you get a little more experience under your belt authoring your IaC files. Under the covers, Bicep is simply converting the Bicep files into ARM templates and then deploying those. In fact, there are commands in Bicep to simply convert your Bicep files to ARM templates files if that's what you want to do for some reason.

If we were to re-write our storage account ARM template example in Bicep, it would look like this:

``` terraform
param storageAccountName string

resource stg 'Microsoft.Storage/storageAccounts@2019-06-01' = {
  name: storageAccountName
  location: 'centralus'
  sku: {
    name: 'Standard_LRS'
  }
  kind: 'StorageV2'
}
```

Deploying a Bicep file is exactly the same as deploying an ARM template, except you generally use a different file extension for Bicep files. Let's assume we'll name this file `storage.bicep`. To deploy two different storage accounts using the above Bicep file, you'd run this:

``` bash
az deployment group create --resource-group {{ site.fake_company_code }}-storage --template-file storage.bicep \
    --parameters storageAccountName='mystorageaccount'
az deployment group create --resource-group {{ site.fake_company_code }}-storage --template-file storage.bicep \
    --parameters storageAccountName='ohlookanotherstorageaccount'
```

If you're starting out with ARM templates, I'd suggest just jumping straight to Bicep because it's easier, but authoring ARM templates is its own type of fun depending on how your little brain works.

## Storing Your ARM Templates or Bicep Files

You have several choices of where to store your ARM templates or Bicep files. Your approach will mostly depend on how you decide to deploy your infrastructure and if/how you want to create linked templates (ARM templates) or modules (Bicep).

Linked templates and modules are the same concept with different names depending on whether you're talking about ARM templates or Bicep, but I'll use the term "module" for both. When you start writing IaC, you'll find that you are frequently deploying the same type of resource over and over again. For example, if you work at a software development company, you may find that you're always deploying a Key Vault service every time you deploy an application. You may find that you have a specific way you like to deploy that Key Vault and you find yourself copying and pasting the resource into the IaC file each time. To get around this, you can define the key vault in a module and then call that module from the ARM template or Bicep file. The tricky thing is that you call the module by specifying a URL, and that URL usually needs to be public.

Here are your main options for storing your IaC files.

|Storage Location|Description|
|----------------|-----------|
|Git repository|You can store your IaC files in a Git repository, such as GitHub. If you are calling modules, those modules need to be from a public repository which rightfully isn't going to sit well with your security team.|
|Template specs<br /><small>([ARM templates](https://learn.microsoft.com/en-us/azure/azure-resource-manager/templates/template-specs?tabs=azure-powershell)) ([Bicep](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/template-specs?tabs=azure-powershell))</small>|Template specs are a way to store your IaC files in Azure itself. You can then apply permissions to the template spec so that only certain users or services can deploy it. This is a great solution for storing your modules.|
|[Deployment stacks](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/deployment-stacks?tabs=azure-powershell)|This is another way to store your IaC files in Azure but with a focus on deploying groups of resources together. This is a great solution for deploying a bunch of resources that will live in the same resource group.|
|[Module registry](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/private-module-registry?tabs=azure-powershell)||


Template Specs
Deployment Stacks
No state
Using in DevOps pipelines
Blueprints & policies